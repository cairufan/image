# kernel杂项记录

## 深入LINUX设备驱动程序内核机制

### 第一章 内核模块

#### 1.1 内核模块的文件格式

- 以内核模块形式存在的驱动程序，其在文件的数据组织形式上是**ELF**格式，更具体地，内核模块是一种普通的可重定位目标文件

- 静态的ELF文件视图总体上可以分为三个部分，头部的ELF header，中间的Section，和尾部的Section header table

---

ELF header:
    大小是52字节，位于文件头部  

Section:
    ELF文件的主体，位于文件视图中间部分的一个连续区域中，但是当模块被内核加载时，会根据各自属性被重新分配到新的内存区域（有些section也可能只是起辅助作用，因而在运行时并不占用实际的内存空间）  

Section header table：
    该部分位于文件视图的尾部，由若干个Section header entry组成，每个entry具有同样的数据结构类型

---

#### 1.2 EXPORT_SYMBOL的内核实现

- 对于由内核模块导出的符号而言，由于在静态链接时无法确定该符号在内存中的最终位置，因此这个地址信息要一直等到模块被成功加载进系统后才有效。在模块加载的过程中，由内核模块加载器负责修改该成员以反映出符号在内存中的最终地址，这也就是所谓的重定位过程

- 之所以把所有向外界导出的符号统一放在一个特殊的section里面，是为了在加载其他模块的时候用来处理那些“未解决的定义”符号，他们会在内核或者某一内核模块的导出符号进行查找时用到

#### 1.3 模块的加载过程

- insmod会首先利用文件系统的接口将其数据读取到用户空间的一段内存中，然后调用sys_init_module接口让内核去处理模块加载的整个过程
  
---

例如用户空间程序insmod首先通过文件系统接口读取内核模块demodev.ko的文件数据，将其放在一块用户空间的存储区域中。然后通过系统调用sys_init_module进入到内核态，同时将void *umod指针作为参数传递过去  

sys_init_module调用load_module，后者将在内核空间利用vmalloc分配一块大小同样为len的地址空间，然后通过copy_from_user函数的调用将用户空间的文件数据复制到内核空间中，从而在内核空间构造出demodev.ko的一个ELF静态的内存视图。该视图称为HDR视图，HDR视图所占用的内存空间在load_module结束时通过vfree释放  

字符串表是ELF文件中的一个section，用来保存ELF文件中各个section的名称或符号名，这些名称以字符串的形式存在  

![QQ截图20210219155403](https://cdn.jsdelivr.net/gh/cairufan/image@main//picture/QQ截图20210219155403.png)

---

